import { nanoid } from "nanoid";
import { type BackendClient } from "./BackendClient";
import { type ShoppingListEvent, type ShoppingListItem } from "./newSchemas";
import { ShoppingList } from "./shopping-list";

export interface ServerClientConnection {
  notifyListChanged(items: ShoppingListItem[]): void;
}

interface ServerDeps {
  shoppingList: ShoppingList;
  backendClient: BackendClient;
}

const ACTIVE_SYNC_INTERVAL = 60 * 1000; // Every minute
const INACTIVE_SYNC_INTERVAL = 10 * 60 * 1000; // Every ten minutes

type SyncMode = "active" | "inactive";

export class Server {
  clients = new Map<string, ServerClientConnection>();
  syncMode: SyncMode = "inactive";
  syncInterval!: ReturnType<typeof setInterval>;

  constructor(private $d: ServerDeps) {
    this.$d.backendClient.onEventsReturned = (events) =>
      this.pushEvents(events);

    this.setSyncMode("inactive");
  }

  setSyncMode(mode: SyncMode) {
    if (this.syncMode === mode && this.syncInterval) return;

    if (this.syncInterval) clearInterval(this.syncInterval);
    this.syncInterval = setInterval(
      () => void this.refreshDataFromBackendClient(),
      mode === "active" ? ACTIVE_SYNC_INTERVAL : INACTIVE_SYNC_INTERVAL,
    );
  }

  connectClient(client: ServerClientConnection) {
    const clientId = nanoid();
    this.clients.set(clientId, client);

    console.log(
      `[SERVER] ${this.clients.size} client(s) (${clientId} connected)`,
    );

    client.notifyListChanged(this.$d.shoppingList.items);

    this.setSyncMode("active");
    this.refreshDataFromBackendClient();

    return clientId;
  }

  onClientDisconnected(clientId: string) {
    this.clients.delete(clientId);

    if (this.clients.size === 0) this.setSyncMode("inactive");

    console.log(
      `[SERVER] ${this.clients.size} client(s) (${clientId} disconnected)`,
    );
  }

  pushEvents(events: ShoppingListEvent[], clientId?: string) {
    const successfulEvents = this.$d.shoppingList.applyEvents(events);
    console.log(
      `[SERVER] Recieved ${events.length} event(s) from client ${clientId}. ${successfulEvents.length} of them were successful.`,
    );

    if (successfulEvents.length === 0) return;

    // When clientId is missing, the events are generated by the backendClient
    if (clientId) {
      this.$d.backendClient.sync(this.$d.shoppingList.items);
    }

    // Notify other clients of changes to the list
    for (const [currentClientId, client] of this.clients.entries()) {
      if (clientId !== currentClientId)
        client.notifyListChanged(this.$d.shoppingList.items);
    }
  }

  async refreshDataFromBackendClient() {
    await this.$d.backendClient.sync(this.$d.shoppingList.items);
  }
}
